// ********RoostGPT********
/*
Test generated by RoostGPT for test java-restassured using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=Update_2f0a6dccef
ROOST_METHOD_SIG_HASH=Update_407df2fa76

Scenario 1: Successful Update of a Product

Details:
    Description: This test is meant to check if the Update function successfully updates a product's details in the repository.
Execution:
    Arrange: Mock the repository's FindByID and Update methods to return a specific product and a successful update respectively.
    Act: Invoke the Update function with the ID of the product and the new product details.
    Assert: Use Go testing facilities to verify that the updated product details match the expected outcomes.
Validation:
    The assertion checks if the updated product details returned by the Update function match the expected new product details. This test is crucial in ensuring that the function correctly updates a product's details in the repository.

Scenario 2: Update of a Non-Existing Product

Details:
    Description: This test is meant to check if the Update function handles the case where the product to be updated does not exist in the repository.
Execution:
    Arrange: Mock the repository's FindByID method to return an error indicating that the product does not exist.
    Act: Invoke the Update function with a non-existing product ID and the new product details.
    Assert: Use Go testing facilities to verify that the function returns an error.
Validation:
    The assertion checks if the function returns an error when trying to update a non-existing product. This test is important in ensuring that the function correctly handles the case where the product to be updated does not exist in the repository.

Scenario 3: Error in Update Process

Details:
    Description: This test is meant to check if the Update function handles an error that occurs during the update process.
Execution:
    Arrange: Mock the repository's Update method to return an error.
    Act: Invoke the Update function with a valid product ID and the new product details.
    Assert: Use Go testing facilities to verify that the function returns an error.
Validation:
    The assertion checks if the function returns an error when there is an error in the update process. This test is important in ensuring that the function correctly handles errors that may occur during the update process.

Scenario 4: Update with Invalid Price

Details:
    Description: This test is meant to check if the Update function handles the case where the new price provided is not a valid number.
Execution:
    Arrange: Provide a new product details with an invalid price.
    Act: Invoke the Update function with a valid product ID and the new product details.
    Assert: Use Go testing facilities to verify that the function returns an error.
Validation:
    The assertion checks if the function returns an error when the new price provided is not a valid number. This test is important in ensuring that the function correctly handles the case where the new price provided is invalid.
*/

// ********RoostGPT********
package allproducts

import (
	"errors"
	"testing"

	"github.com/google/go-cmp/cmp"
)

type MockRepository struct {
	product  AllProduct
	err      error
	findByID bool
	update   bool
}

func (m *MockRepository) FindByID(ID int) (AllProduct, error) {
	if m.findByID {
		return m.product, nil
	}
	return AllProduct{}, m.err
}

func (m *MockRepository) Update(allProduct AllProduct) (AllProduct, error) {
	if m.update {
		return m.product, nil
	}
	return AllProduct{}, m.err
}

func TestUpdate(t *testing.T) {
	tests := []struct {
		name      string
		repo      *MockRepository
		id        int
		newProduct AllProductRequest
		want      AllProduct
		wantErr   bool
	}{
		{
			name:      "Successful Update of a Product",
			repo:      &MockRepository{product: AllProduct{Id: 1, Name_product: "Product 1", Price: 100}, findByID: true, update: true},
			id:        1,
			newProduct: AllProductRequest{Id:1, Name_product: "Product 1 Updated", Price: json.Number("200")},
			want:      AllProduct{Id: 1, Name_product: "Product 1 Updated", Price: 200},
			wantErr:   false,
		},
		{
			name:      "Update of a Non-Existing Product",
			repo:      &MockRepository{err: errors.New("Product not found")},
			id:        1,
			newProduct: AllProductRequest{Id:1, Name_product: "Product 1 Updated", Price: json.Number("200")},
			want:      AllProduct{},
			wantErr:   true,
		},
		{
			name:      "Error in Update Process",
			repo:      &MockRepository{product: AllProduct{Id: 1, Name_product: "Product 1", Price: 100}, findByID: true, err: errors.New("Update failed")},
			id:        1,
			newProduct: AllProductRequest{Id:1, Name_product: "Product 1 Updated", Price: json.Number("200")},
			want:      AllProduct{},
			wantErr:   true,
		},
		{
			name:      "Update with Invalid Price",
			repo:      &MockRepository{product: AllProduct{Id: 1, Name_product: "Product 1", Price: 100}, findByID: true, update: true},
			id:        1,
			newProduct: AllProductRequest{Id:1, Name_product: "Product 1 Updated", Price: json.Number("invalid")},
			want:      AllProduct{},
			wantErr:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			s := &service{ tt.repo }
			got, err := s.Update(tt.id, tt.newProduct)
			if (err != nil) != tt.wantErr {
				t.Errorf("Update() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !cmp.Equal(got, tt.want) {
				t.Errorf("Update() = %v, want %v", got, tt.want)
			}
		})
	}
}
